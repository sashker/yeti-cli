#!/usr/bin/env python

import os
import sys
import signal
import xmlrpclib
import pprint
import syslog
import socket

import yaml
import requests

from cmd import Cmd


CFG_PATH = '/etc/sems/etc/yeticmd.yaml'

def get_config(path):
    path = os.getenv('YETI_CMD_CFG_PATH', path)
    try:
        with open(path) as f:
            cfg = yaml.load(f)
    except IOError as e:
        print("Can't open config file {}, {}".format(path, e))
        sys.exit(1)
    except ScannerError as e:
        print("Can't parce config file {}, {}".format(path, e))
    return cfg


def walk_over_keys(v, keys, key):
    kk = key[:]
    for i, k in enumerate(keys):
        if k == '*':    #walk over arrays key
            if type(v) is not list:
                print "invalid keyword '*' for non list type {}".format(type(v))
                return
            else:
                if i+1 == len(keys):
                    print "keyword '*' must precede valid key"
                    return
                for j, l in enumerate(v):
                    kk[i+1] = "{}[{}]".format(key[i+1], j)
                    walk_over_keys(l, keys[i+1:], kk)
                break
        if k not in v:
            print "invalid item '{}'".format(k)
            return
        v = v[k]
        if i+1 == len(keys):
            gprint(v)
    return


def make_strings(data):
    h = []
    d = []
    for k in sorted(data):
        h.append(str(k))
        d.append(str(data[k]))
    return [h, d]


def make_template(data):
    l = [None] * len(data[0])
    for e in data:
        for n,i in enumerate(l):
            if len(e[n]) > l[n]:
                l[n] = len(e[n])
    tl = ''
    for i in l:
        tl = tl + '{{:^{}}}'.format(i+2) + '|'
    return tl


def formated_print(data):
    if not data:
        print('No data to print')
    if isinstance(data, dict):
        result = make_strings(data)
    else:
        result = []
        for e in data:
            d = make_strings(e)
            if result:
                result.append(d[1])
            else:
                result = d

    tl = make_template(result)
    header = tl.format(*result[0])
    print(header)
    print('-'*len(header))
    for e in result[1:]:
        s = tl.format(*e)
        print(s)


def can_formating(data):
    if not data:
        return False
    if isinstance(data, dict):
        for k,v in data.items():
            if isinstance(k, list) or isinstance(k,dict) or isinstance(v, list) or isinstance(v,dict):
                return False
    elif isinstance(data, list):
        for v in data:
            if isinstance(v, list):
                return False
            elif isinstance(v,dict) and not can_formating(v):
                return False
    elif isinstance(data, (int, long, basestring)):
        return False

    return True


def gprint(data, state=True):
    if state and can_formating(data):
        formated_print(data)
    else:
        pprint.PrettyPrinter(indent=4).pprint(data)


class shell(Cmd):

    def __init__(self):
        self.user = os.getenv('YETI_CMD_USER', 'anonymous')
        self.prompt = self.user+' YETI> '
        self.doc_header = ''
        self.cfg = dict()
        self.c_node = None
        self.nodes = []
        self.formatting = True
        Cmd.__init__(self)

    def sigint_handler(self, signum, frame):
        self.stdout.write('\n'+self.prompt)
        self.stdout.flush()

    def rpc_do(self, args):
        if self.c_node.get(u'id') is None:
            return None
        addr = self.c_node[u'rpc_uri']
        s = xmlrpclib.ServerProxy(addr)
        data = s.di('yeti', *args)
        return data

    def rpc_complete(self, args):
        try:
            a = args[:]
            a.append('_list')
            return [c[0]+' ' for c in self.rpc_do(a)]
        except BaseException as err:
            return None

    def rpc_command(self, line):
        try:
            syslog.syslog('{}: {}->{}'.format(self.ip, self.c_node.get(u'id'), line))
            if self.c_node.get(u'id') is None:
                raise BaseException("you should choose node first")
            cc = [c.strip() for c in line.split('&')]
            for c in cc:
                args = c.split('|')
                cmds = args[0].split()
                keys = args[1].strip() if len(args) > 1 else None

                if len(cc) > 1:
                    print "{}...".format(args[0])
                data = self.rpc_do(cmds)

                if keys is not None and len(keys) > 0:
                    chunks = [k.strip() for k in keys.split(',')]
                    for k in chunks:
                        if len(chunks) > 1:
                            print "{}:".format(k)
                        kk = k.split('.')
                        walk_over_keys(data, kk[:], kk)
                else:
                    if keys is not None:
                        data = data[1]
                    gprint(data, self.formatting)
        except BaseException as err:
            print err

    def default(self, line):
        self.rpc_command(line)

    def do_EOF(self, line):
        print ''
        sys.exit()

    def do_all(self, line):
        'apply rpc_cmd for all nodes from config'
        tmp_node_id = self.c_node.get(u'id')
        for i in (n.get(u'id') for n in self.nodes):
            print "Node {}: ".format(i),
            self.switch_to_node(i)
            self.rpc_command(line)
        self.switch_to_node(tmp_node_id)

    def complete_all(self, text, line, begidx, endidx):
        return self.completedefault(text, ' '.join(line.split()[1:]), begidx, endidx)

    def completenames(self, text, *ignored):
        dotext = 'do_'+text
        r = [a[3:] for a in self.get_names() if a.startswith(dotext)]
        if self.c_node.get(u'id') is None:
            return r
        return r+[a for a in self.rpc_complete([]) if a.startswith(text)]

    def completedefault(self, text, line, begidx, endidx):
        if self.c_node.get(u'id') is None:
            return []
        q = line.split()
        if len(q) and q[0] in [a[3:] for a in self.get_names()]:
            return []
        c = self.rpc_complete(q)
        if c is None:
            p = self.rpc_complete(q[:-1])
            c = [] if p is None else p
        return [a for a in c if a.startswith(text)]

    def emptyline(self):
        pass

    def do_exit(self, arg):
        'exit shell'
        syslog.syslog('{}: Session disconnected'.format(self.ip))
        sys.exit()

    def do_list(self, arg):
        'list available nodes'
        header = "node_id  rpc_uri"
        print(header)
        print('-'*len(header))
        for n in self.nodes:
            print('{0:^7}  {1}'.format(n.get(u'id'), n.get(u'rpc_uri')))

    def do_use(self, arg):
        'use <node_id> - set current node'
        try:
            if not len(arg):
                raise BaseException('cmd requires node_id')
            if int(arg) not in (n.get(u'id') for n in self.nodes):
                raise BaseException('invalid node id. use list to see available')
            prev_node_id = self.c_node.get(u'id') if self.c_node else 'empty'
            self.switch_to_node(int(arg))
            self.prompt = "{}@YETI:{}> ".format(self.user, self.c_node.get(u'id'))
            print "node changed from {} to {}".format(prev_node_id, self.c_node.get(u'id'))
        except BaseException as err:
            print err
        pass

    def do_formating(self, arg):
        "formating [enable|disable]"
        if not arg:
            print(self.formatting)
        elif len(arg.split()) == 1 and arg in ['enable', 'disable']:
            print("{0} formating".format(arg))
            self.formatting = True if arg == 'enable' else False

    def complete_formating(self, text, line, begidx, endidx):
        #print(text, line, begidx, endidx)
        if len(line.split()) > 2:
            print("\n You can apply only enable|disable args\n")
            return []
        return [a for a in ['enable', 'disable'] if a.startswith(text)]

    def read_cfg(self):
        self.cfg = get_config(CFG_PATH)

    def load_nodes(self):
        try:
            ans = requests.get(
                self.cfg.get('nodes_url'),
                timeout=self.cfg.get(u'timeout'),
            )
            if int(requests.__version__.split('.')[0]) < 1:
                self.nodes = ans.json
            else:
                self.nodes = ans.json()
        except (requests.exceptions.ConnectionError, requests.exceptions.ReadTimeout) as err:
            print(err)
            sys.exit(-1)

    def switch_to_node(self, arg):
        for n in self.nodes:
            if n[u'id'] == arg:
                self.c_node = n
                break
        else:
            raise BaseException("can't switch to node {}".format(arg))

    def preloop(self):
        self.read_cfg()
        self.load_nodes()
        socket.setdefaulttimeout(self.cfg[u'timeout'])
        if 'default_node' in self.cfg:
            self.do_use(str(self.cfg['default_node']))
        signal.signal(signal.SIGINT, self.sigint_handler)
        self.ip = os.getenv('SSH_CLIENT', 'Local')

if __name__ == '__main__':
    try:
        syslog.syslog("Session started")
        shell().cmdloop()
    except IOError as e:
        print e
    except KeyboardInterrupt as e:
        print ''
